---
- name: Fail if not in Git repository
  assert:
    that: image_tag != ""
    fail_msg: "Not in a Git repository â€“ cannot determine image tag"

- name: Get AWS Account ID
  command: aws sts get-caller-identity --query Account --output text
  register: aws_account
  changed_when: false

- name: Set ECR facts
  set_fact:
    account_id: "{{ aws_account.stdout }}"
    ecr_registry: "{{ aws_account.stdout }}.dkr.ecr.{{ aws_region }}.amazonaws.com"
    frontend_image: "{{ ecr_registry }}/{{ frontend_repo }}:{{ image_tag }}"
    backend_image: "{{ ecr_registry }}/{{ backend_repo }}:{{ image_tag }}"

- name: ECR Login
  command: >
    aws ecr get-login-password --region {{ aws_region }} |
    docker login --username AWS --password-stdin {{ ecr_registry }}
  no_log: true

- name: Build, Scan & Push Images in Parallel
  block:
    - name: Build and process images
      loop:
        - { name: frontend, path: "../../apps/frontend" }
        - { name: backend, path: "../../apps/backend" }
      loop_control:
        loop_var: app
      async: 600
      poll: 0
      register: build_jobs
      vars:
        repo_name: "cobank-{{ app.name }}"
        full_image: "{{ ecr_registry }}/{{ repo_name }}:{{ image_tag }}"
      tasks:
        - name: Build {{ app.name }} image with cache
          docker_image:
            name: "{{ repo_name }}"
            tag: "{{ image_tag }}"
            build:
              path: "{{ app.path }}"
              pull: yes
              cache_from:
                - "{{ repo_name }}:latest"
            source: build
            state: present

        - name: Trivy scan {{ app.name }} (fail on HIGH/CRITICAL)
          command: docker run --rm aquasec/trivy image --exit-code 1 --no-progress --severity HIGH,CRITICAL {{ repo_name }}:{{ image_tag }}

        - name: Tag and push {{ app.name }} image
          shell: |
            docker tag {{ repo_name }}:{{ image_tag }} {{ full_image }}
            docker tag {{ repo_name }}:{{ image_tag }} {{ ecr_registry }}/{{ repo_name }}:latest
            docker push {{ full_image }}
            docker push {{ ecr_registry }}/{{ repo_name }}:latest

    - name: Wait for parallel image jobs
      async_status:
        jid: "{{ item.async_result.job_id }}"
      loop: "{{ build_jobs.results }}"
      loop_control:
        loop_var: item
      register: async_result
      until: async_result.finished
      retries: 60
      delay: 10

- name: Update kubeconfig
  command: aws eks update-kubeconfig --name {{ cluster_name }} --region {{ aws_region }}
  changed_when: false

- name: Apply Kubernetes manifests (idempotent)
  kubernetes.core.k8s:
    state: present
    definition: "{{ lookup('file', item) | from_yaml_all }}"
  loop:
    - "{{ playbook_dir }}/../../k8s/base/namespace.yaml"
    - "{{ playbook_dir }}/../../k8s/base/frontend-deployment.yaml"
    - "{{ playbook_dir }}/../../k8s/base/backend-deployment.yaml"
    - "{{ playbook_dir }}/../../k8s/base/services.yaml"
    - "{{ playbook_dir }}/../../k8s/base/hpa.yaml"
    - "{{ playbook_dir }}/../../k8s/istio/gateway.yaml"
    - "{{ playbook_dir }}/../../k8s/istio/virtualservice.yaml"

- name: Wait for frontend rollout
  kubernetes.core.k8s_rollout_status:
    api_version: apps/v1
    kind: Deployment
    name: frontend
    namespace: "{{ app_namespace }}"
    wait: yes
    timeout: 300

- name: Trigger ArgoCD sync (force if needed)
  uri:
    url: "https://{{ argocd_server }}/api/v1/applications/{{ argocd_app_name }}/sync"
    method: POST
    headers:
      Authorization: "Bearer {{ lookup('env', 'ARGOCD_TOKEN') | default(omit) }}"
    body_format: json
    body: '{"prune": true, "dryRun": false}'
    validate_certs: no
    status_code: 200
  ignore_errors: yes  # Fallback if ArgoCD not used or token missing

- name: Deployment successful
  debug:
    msg: |
      CoBank platform deployed!
      Tag: {{ image_tag }}
      Frontend: {{ frontend_image }}
      Backend: {{ backend_image }}
      Access via Istio gateway or port-forward.